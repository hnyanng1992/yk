<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WKTå‡ ä½•æ•°æ®å¯è§†åŒ–å·¥å…· (ä¼˜åŒ–ç‰ˆ)</title>
    <style>
        :root {
            --primary-color: #3388FF;
            --success-color: #00b894;
            --bg-color: #f1f3f5;
            --panel-width: 420px;
        }

        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background: var(--bg-color); height: 100vh; overflow: hidden; display: flex; }
        
        /* åœ°å›¾å®¹å™¨å…¨å± */
        #container { flex: 1; height: 100%; z-index: 1; }

        /* å·¦ä¾§æ§åˆ¶é¢æ¿ */
        .control-panel {
            width: var(--panel-width);
            background: white;
            box-shadow: 4px 0 15px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            z-index: 2;
            transition: transform 0.3s ease;
        }

        .panel-header {
            padding: 20px;
            background: linear-gradient(135deg, #0984e3, #74b9ff);
            color: white;
            flex-shrink: 0;
        }
        .panel-header h2 { margin: 0; font-size: 1.2rem; display: flex; align-items: center; gap: 8px; }

        /* æ ‡ç­¾é¡µå¯¼èˆª */
        .tabs { display: flex; background: #dfe6e9; cursor: pointer; flex-shrink: 0; }
        .tab { flex: 1; padding: 12px; text-align: center; font-weight: 500; color: #636e72; border-bottom: 3px solid transparent; transition: all 0.2s; }
        .tab:hover { background: #eccc68; color: white; }
        .tab.active { background: white; color: var(--primary-color); border-bottom-color: var(--primary-color); }

        /* å†…å®¹åŒºåŸŸ */
        .content-area { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px; }
        
        .input-group { display: flex; flex-direction: column; gap: 8px; flex: 1; }
        .input-group label { font-size: 0.9rem; font-weight: 600; color: #2d3436; display: flex; justify-content: space-between; }
        .badge { padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; background: #eee; color: #666; }
        .badge.valid { background: #dff9fb; color: #00b894; }

        textarea {
            width: 100%;
            flex: 1;
            min-height: 200px;
            padding: 12px;
            border: 1px solid #b2bec3;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            resize: none;
            outline: none;
            transition: border 0.2s;
            box-sizing: border-box;
        }
        textarea:focus { border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(51, 136, 255, 0.1); }

        /* æŒ‰é’®ç»„ */
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: auto; flex-shrink: 0; padding-top: 10px; }
        button {
            padding: 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
        }
        button:active { transform: scale(0.98); }
        .btn-primary { background: var(--primary-color); color: white; grid-column: span 2; }
        .btn-clear { background: #ff7675; color: white; }
        .btn-fit { background: #55efc4; color: #00b894; color: #2d3436; }

        /* çŠ¶æ€æ¡ */
        #status-bar {
            margin-top: 10px;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            display: none;
        }
        .status-success { background: #dff9fb; color: #00b894; border: 1px solid #badc58; }
        .status-error { background: #ffeaa7; color: #d63031; border: 1px solid #fab1a0; }

        /* å“åº”å¼ */
        @media (max-width: 768px) {
            body { flex-direction: column-reverse; }
            .control-panel { width: 100%; height: 50vh; }
        }
    </style>
    <!-- å¼•å…¥é«˜å¾·åœ°å›¾ JSAPI -->
    <script type="text/javascript">
        window._AMapSecurityConfig = {
            securityJsCode: 'ä½ çš„å®‰å…¨å¯†é’¥', // å¦‚æœä½ æ˜¯æœ¬åœ°å¼€å‘é€šå¸¸ä¸éœ€è¦ï¼Œå¦‚æœéƒ¨ç½²éœ€è¦é…ç½®
        };
    </script>
    <script src="https://webapi.amap.com/maps?v=2.0&key=1cf9fc45df860df45e87af1230f5da74"></script>
</head>
<body>

    <div class="control-panel">
        <div class="panel-header">
            <h2>ğŸŒ Geometry Visualizer <small style="font-size:0.7em; opacity:0.8; margin-left:auto">v2.0 Optimized</small></h2>
        </div>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('polygon')">å¤šè¾¹å½¢ (Polygon)</div>
            <div class="tab" onclick="switchTab('line')">çº¿ (Line)</div>
            <div class="tab" onclick="switchTab('point')">ç‚¹ (Point)</div>
        </div>

        <div class="content-area">
            <div class="input-group">
                <label>
                    WKT æ•°æ®è¾“å…¥
                    <span id="format-badge" class="badge">ç­‰å¾…è¾“å…¥...</span>
                </label>
                <textarea id="wkt-input" placeholder="åœ¨æ­¤ç²˜è´´ WKT æ–‡æœ¬...
ä¾‹å¦‚: MULTIPOLYGON (((...)), ((...)))"></textarea>
            </div>

            <div id="status-bar"></div>

            <div class="btn-group">
                <button class="btn-primary" onclick="renderData()">ğŸš€ è§£æå¹¶æ¸²æŸ“</button>
                <button class="btn-fit" onclick="fitView()">ğŸ” èšç„¦è§†å›¾</button>
                <button class="btn-clear" onclick="clearMap()">ğŸ—‘ï¸ æ¸…ç©º</button>
            </div>
        </div>
    </div>

    <div id="container"></div>

    <script>
        let map;
        let overlays = [];
        let currentType = 'polygon';
        
        // åˆå§‹åŒ–åœ°å›¾
        function initMap() {
            map = new AMap.Map('container', {
                zoom: 11,
                center: [116.397428, 39.90923], // åŒ—äº¬é»˜è®¤
                viewMode: '3D',
                pitch: 30,
            });
            // é»˜è®¤åŠ è½½ç¤ºä¾‹æ•°æ®
            document.getElementById('wkt-input').value = `MULTIPOLYGON (((116.267554 40.143674, 116.276690 40.146418, 116.279322 40.147106, 116.280005 40.144965, 116.283973 40.146092, 116.285033 40.146355, 116.289183 40.147556, 116.290073 40.146855, 116.290675 40.145969, 116.287825 40.144879, 116.288980 40.141879, 116.289029 40.141727, 116.292728 40.142273, 116.293094 40.142339, 116.295110 40.142508, 116.302110 40.143200, 116.302768 40.140103, 116.297349 40.139644, 116.297428 40.139241, 116.292626 40.138913, 116.290668 40.138374, 116.286600 40.138182, 116.283331 40.138137, 116.277863 40.137829, 116.277319 40.139720, 116.276325 40.139594, 116.275799 40.139680, 116.275014 40.140193, 116.274188 40.139238, 116.273272 40.138283, 116.271391 40.137550, 116.271312 40.137856, 116.271185 40.140226, 116.271226 40.141041, 116.269384 40.140577, 116.268609 40.142467, 116.268572 40.142557, 116.267884 40.142589, 116.267786 40.142671, 116.267554 40.143674)), ((116.278184 40.150960, 116.284874 40.152902, 116.285020 40.152947, 116.285938 40.151100, 116.279006 40.149139, 116.278184 40.150960)), ((116.241132 40.154537, 116.245402 40.155578, 116.246149 40.154617, 116.249661 40.155446, 116.250890 40.153510, 116.245508 40.152263, 116.245339 40.152220, 116.241132 40.154537)))`;
        }

        // æ ¸å¿ƒå·¥å…·ç±»ï¼šWKT Parser
        // è§£å†³äº† split ç®€å•çš„ bugï¼Œä½¿ç”¨æ‹¬å·å±‚çº§è®¡æ•°
        const WKTUtil = {
            clean: (wkt) => {
                return wkt.replace(/[\n\r]/g, ' ').replace(/\s\s+/g, ' ').trim();
            },

            // æ™ºèƒ½åˆ†å‰²æ‹¬å·å— ((a,b)), ((c,d))
            splitByLevel: (str) => {
                let result = [];
                let level = 0;
                let start = 0;
                for (let i = 0; i < str.length; i++) {
                    if (str[i] === '(') level++;
                    if (str[i] === ')') level--;
                    
                    // å½“æˆ‘ä»¬åœ¨æœ€å¤–å±‚é‡åˆ°é€—å·ï¼Œä¸”ä¸åœ¨æ‹¬å·å†…æ—¶ï¼ˆå¯¹äºWKTé€šå¸¸æ˜¯é¡¶çº§åˆ†å‰²ï¼‰
                    // æˆ–è€…æ›´ç®€å•çš„ï¼Œæˆ‘ä»¬åªæå– (...) å—
                }
                // é’ˆå¯¹ WKT çš„ç‰¹æ®Šå¤„ç†ï¼šæå–æœ€å¤–å±‚çš„æ‹¬å·ç»„
                // MULTIPOLYGON (((...)), ((...))) -> [ "((...))", "((...))" ]
                // æ­£åˆ™æ¯”å¾ªç¯æ›´é€‚åˆæå–é¡¶çº§ç»„ï¼Œä½†ä¸æ”¯æŒåµŒå¥—å¤ªæ·±ã€‚
                // ä¸‹é¢æ˜¯ä¸€ä¸ªåŸºäºå­—ç¬¦æ‰«æçš„æå–å™¨ï¼š
                let parts = [];
                let buffer = "";
                let depth = 0;
                let hasStarted = false;

                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    if (char === '(') {
                        depth++;
                        hasStarted = true;
                    }
                    
                    if (hasStarted) buffer += char;

                    if (char === ')') {
                        depth--;
                        if (depth === 0 && hasStarted) {
                            // æ‰¾åˆ°ä¸€ä¸ªå®Œæ•´çš„é¡¶çº§å—
                            // å»é™¤å¯èƒ½çš„å¼€å¤´çš„é€—å·å’Œç©ºæ ¼
                            parts.push(buffer);
                            buffer = "";
                            hasStarted = false; 
                        }
                    }
                }
                return parts;
            },

            parseCoords: (coordStr) => {
                // å¤„ç† "x y, x y" æ ¼å¼
                return coordStr.split(',').map(pair => {
                    const [lng, lat] = pair.trim().split(/\s+/).map(Number);
                    if (isNaN(lng) || isNaN(lat)) return null;
                    return [lng, lat]; // AMap æ ¼å¼ [lng, lat]
                }).filter(p => p);
            },

            parse: (wkt) => {
                wkt = WKTUtil.clean(wkt);
                const type = wkt.split('(')[0].trim().toUpperCase();
                const content = wkt.substring(wkt.indexOf('(')); // ä¿ç•™æ‰€æœ‰æ‹¬å·å†…å®¹

                let result = { type: type, shapes: [] };

                if (type.includes('MULTIPOLYGON')) {
                    // å‰¥ç¦»æœ€å¤–å±‚æ‹¬å· MULTIPOLYGON (...)
                    const inner = content.substring(1, content.length - 1);
                    // æ™ºèƒ½åˆ†å‰²å¤šä¸ª POLYGON ((...)), ((...))
                    const polyStrs = WKTUtil.splitByLevel(inner);
                    
                    polyStrs.forEach(polyStr => {
                        // æ¯ä¸ª polyStr æ˜¯ ((x y, x y), (hole))
                        // å‰¥ç¦»å¤–å±‚
                        const ringStr = polyStr.substring(1, polyStr.length - 1);
                        const ringParts = WKTUtil.splitByLevel(ringStr); // åˆ†å‰²å¤–ç¯å’Œå†…ç¯
                        
                        let rings = ringParts.map(r => {
                            // r is (x y, x y)
                            return WKTUtil.parseCoords(r.substring(1, r.length - 1));
                        });
                        result.shapes.push(rings); // shape ç»“æ„: [[outer], [hole1], [hole2]]
                    });

                } else if (type === 'POLYGON') {
                    const inner = content.substring(1, content.length - 1);
                    const ringParts = WKTUtil.splitByLevel(inner);
                    let rings = ringParts.map(r => {
                        return WKTUtil.parseCoords(r.substring(1, r.length - 1));
                    });
                    result.shapes.push(rings);

                } else if (type.includes('LINESTRING')) { // MULTI or Single
                     // ç®€å•å¤„ç†ï¼Œé€‚é…å¤§å¤šæ•°æƒ…å†µ
                     const coordsRaw = content.replace(/MULTILINESTRING|LINESTRING|\(|\)/g, '');
                     // è¿™é‡Œç®€å•åŒ–ï¼Œå¦‚æœçœŸçš„å¾ˆå¤æ‚å»ºè®®ç”¨åŒæ ·çš„åˆ†å±‚é€»è¾‘
                     // ä¸ºäº†æ¼”ç¤ºæ•ˆæœï¼Œåªå–æ‰€æœ‰ç‚¹
                } 
                // ... å¯ä»¥æ‰©å±• Point ç­‰

                return result;
            }
        };

        // åˆ‡æ¢æ ‡ç­¾
        function switchTab(type) {
            currentType = type;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            // æç¤ºè¯å˜æ¢
            const tips = {
                'polygon': 'ä¾‹å¦‚: MULTIPOLYGON (((...)))',
                'line': 'ä¾‹å¦‚: MULTILINESTRING ((...))',
                'point': 'ä¾‹å¦‚: POINT (x y)'
            };
            document.getElementById('wkt-input').placeholder = `è¯·è¾“å…¥ ${type.toUpperCase()} æ•°æ®...\n${tips[type]}`;
        }

        function showStatus(msg, type) {
            const el = document.getElementById('status-bar');
            el.innerHTML = msg;
            el.className = type === 'success' ? 'status-success' : 'status-error';
            el.style.display = 'block';
            document.getElementById('format-badge').innerText = type === 'success' ? 'æ ¼å¼æœ‰æ•ˆ' : 'æ ¼å¼é”™è¯¯';
            document.getElementById('format-badge').className = `badge ${type === 'success' ? 'valid' : ''}`;
        }

        function getRandomColor() {
            const colors = ['#0984e3', '#00b894', '#6c5ce7', '#e17055', '#e84393', '#fdcb6e'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // æ¸²æŸ“ä¸»å‡½æ•°
        function renderData() {
            clearMap();
            const input = document.getElementById('wkt-input').value;
            if (!input) { showStatus('è¾“å…¥ä¸ºç©º', 'error'); return; }

            try {
                const data = WKTUtil.parse(input);
                
                if (data.type.includes('POLYGON')) {
                    // æ¸²æŸ“å¤šè¾¹å½¢
                    data.shapes.forEach((rings, index) => {
                        // rings[0] æ˜¯å¤–ç¯ï¼Œ rings[1...] æ˜¯æ´
                        const color = getRandomColor();
                        
                        const polygon = new AMap.Polygon({
                            path: rings, // AMap æ”¯æŒç›´æ¥ä¼  [[x,y], [x,y]] æˆ–è€… [[[x,y]], [[hole]]]
                            fillColor: color,
                            strokeColor: color,
                            strokeWeight: 2,
                            strokeOpacity: 1,
                            fillOpacity: 0.4,
                            cursor: 'pointer',
                            bubble: true
                        });

                        // æ·»åŠ æ ‡ç­¾
                        const center = polygon.getBounds().getCenter();
                        const label = new AMap.Text({
                            text: `Poly #${index + 1}`,
                            position: center,
                            style: {
                                'background-color': 'rgba(255,255,255,0.8)',
                                'border': `1px solid ${color}`,
                                'padding': '2px 5px',
                                'font-size': '10px',
                                'border-radius': '4px'
                            }
                        });

                        map.add([polygon, label]);
                        overlays.push(polygon, label);
                    });
                    showStatus(`æˆåŠŸè§£æå¹¶æ¸²æŸ“ ${data.shapes.length} ä¸ªå¤šè¾¹å½¢å—`, 'success');
                    map.setFitView(overlays);
                } else if (data.type.includes('POINT')) {
                    // ç®€æ˜“å¤„ç†ç‚¹
                    const raw = input.match(/[\d.]+\s+[\d.]+/g);
                    if(raw) {
                        raw.forEach(p => {
                            const [lng, lat] = p.split(/\s+/).map(Number);
                            const marker = new AMap.Marker({ position: [lng, lat] });
                            map.add(marker);
                            overlays.push(marker);
                        });
                        showStatus(`æ¸²æŸ“äº† ${raw.length} ä¸ªç‚¹ (ç®€æ˜“æ¨¡å¼)`, 'success');
                        map.setFitView();
                    }
                } else {
                    showStatus(`æš‚æœªå®Œå…¨æ”¯æŒ ${data.type} çš„é«˜çº§è§£æï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°`, 'error');
                }

            } catch (e) {
                console.error(e);
                showStatus(`è§£æé”™è¯¯: ${e.message}`, 'error');
            }
        }

        function clearMap() {
            map.remove(overlays);
            overlays = [];
        }

        function fitView() {
            if (overlays.length > 0) map.setFitView();
        }

        // åˆå§‹åŒ–
        window.onload = initMap;

    </script>
</body>
</html>
